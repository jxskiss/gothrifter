package generator

import "fmt"

var headerTmpl = fmt.Sprintf(`
// GENERATED BY GOTHRIFTER (version: %s)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package {{ .Name }}

import (
	"bytes"
	"context"
	"fmt"
	"sync"

	"github.com/thrift-iterator/go"
	"github.com/thrift-iterator/go/protocol"
	"github.com/jxskiss/gothrifter/lib/thrift"

	{{ range .Includes }} {{ .Name }} "{{ .ImportPath }}"
	{{ end }}
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = bytes.Equal
	_ = context.Canceled
	_ = fmt.Printf
	_ = sync.WaitGroup{}
	_ = protocol.MessageHeader{}
	_ = thrifter.DefaultConfig
	_ = thrift.UNKNOWN_APPLICATION_EXCEPTION

	{{ range .Includes }} _ = {{ .Name }}.GoUnusedProtection__
	{{ end }}

	GoUnusedProtection__ = 0
)
`, Version)

const constsTmpl = `
const (
	MaxMapElements    = 1 << 20
	MaxSetElements    = 1 << 20
	MaxListElements   = 1 << 20
	MaxServerPipeline = 10
)

{{ range $enum := .Enums }}
type {{ $enum.Name }} int32

const (
	{{ range $enum.Values }}
	{{ $enum.Name }}_{{ .Name }} {{ $enum.Name }} = {{ .Value }}
	{{ end }}
)
{{ end }}

{{ range .Constants }}
{{ if (eq .Type.Category "container") }}
var {{ .Name }} = {{ formatValue .Value }}
{{ else }}
const {{ .Name }} {{ formatType .Type }} = {{ formatValue .Value }}
{{ end }}
{{ end }}
`

const typedefsTmpl = `
{{ range .Typedefs }}
type {{ .Alias }} = {{ formatType .Type }}
{{ end }}
`

const structsTmpl = `
{{ range $struct := .Structs }}

{{ range $struct.Fields }}
{{ if (and .Optional .Default) }}
var {{ $struct.Name }}_{{ .Name }}_DEFAULT = {{ formatValue .Default }}
{{ end }}
{{ end }}

type {{ $struct.Name }} struct { {{ range $struct.Fields }}
	{{ fieldName .Name }} {{ if (and .Optional (not .Default)) }}*{{ end }}{{ formatType .Type }}` +
	" `thrift:\"{{ .Name }},{{ .ID }},{{ .Requiredness }}\" json:\"{{ toSnakeCase .Name }}{{ if .Optional }},omitempty{{ end }}\"` " +
`	{{ end }}
}

func New{{ $struct.Name }}() *{{ $struct.Name }} {
	return &{{ $struct.Name }}{
	{{ range $struct.Fields }}
	{{ if (and .Optional .Default) }}
	{{ .Name }} : {{ $struct.Name }}_{{ .Name }}_DEFAULT,
	{{ end }}
	{{ end }}
	}
}
{{ end }}
`

const exceptionsTmpl = `
{{ range $exc := .Exceptions }}
func (p *{{ .Name }}) Error() string {
	return fmt.Sprintf("%T %#v", *p, *p)
}
{{ end }}
`

const servicesTmpl = `
{{ range $name, $svc := .Services }}
{{ formatArguments $svc }}

type {{ $svc.Name }}Client struct {
	thrift.Client
}

func New{{ $svc.Name }}Client(cli thrift.Client) *{{ $svc.Name }}Client {
	return &{{ $svc.Name }}Client{Client: cli}
}

{{ range $meth := $svc.Methods }}
func (cli *{{ $svc.Name }}Client) {{ $meth.Name }}(ctx context.Context,
	{{ range $meth.Arguments }}{{ .Name }} {{ if (eq .Type.Category "identifier") }}*{{ end }}{{ formatType .Type }}, {{ end }}
	) ( {{ if (not (or $meth.Oneway (eq $meth.ReturnType.Name "void"))) }} *{{ formatType $meth.ReturnType }}, {{ end }} error) {
	args := &{{ $svc.Name }}{{ $meth.Name }}Args{
		{{ range $meth.Arguments }}
		{{ fieldName .Name }}: {{ .Name }},
		{{ end }}
	}
	{{ if $meth.Oneway }}
	err := cli.Client.Invoke(ctx, "{{ $meth.Name }}", args, nil)
	return err
	{{ else if (eq $meth.ReturnType.Name "void") }}
	result := New{{ $svc.Name }}{{ $meth.Name }}Result()
	err := cli.Client.Invoke(ctx, "{{ $meth.Name }}", args, result)
	return err
	{{ else }}
	result := New{{ $svc.Name }}{{ $meth.Name }}Result()
	err := cli.Client.Invoke(ctx, "{{ $meth.Name }}", args, result)
	if err != nil {
		return nil, err
	}

	{{ if $meth.Exceptions }}
	{{ range $exc := $meth.Exceptions }}
	if result.{{ fieldName $exc.Name }} != nil {
		return nil, result.{{ fieldName $exc.Name }}
	}
	{{ end }}
	{{ end }}

	return result.Success, nil
	{{ end }}
}
{{ end }}

type {{ $svc.Name }}Handler interface {
	{{ range $meth := $svc.Methods }}
	{{ $meth.Name }}(ctx context.Context, {{ range $meth.Arguments }}{{ .Name }} {{ if (eq .Type.Category "identifier") }}*{{ end }}{{ formatType .Type }}, {{ end }} ) (
		{{ if (not $meth.Oneway) }}{{ if (not (eq $meth.ReturnType.Name "void")) }} *{{ formatType $meth.ReturnType }}, {{ end }} error {{ end }})
	{{ end }}
}

type {{ $svc.Name }}Server struct {
	handler {{ $svc.Name }}Handler
}

func New{{ $svc.Name }}Server(h {{ $svc.Name }}Handler) *{{ $svc.Name }}Server {
	return &{{ $svc.Name }}Server{handler: h}
}

func (h {{ $svc.Name }}Server) Process(ctx context.Context, reader *thrifter.Decoder, writer *thrifter.Encoder) error {
	type request struct {
		header protocol.MessageHeader
		args   interface{}
	}
	ch := make(chan request, MaxServerPipeline)
	ctx, cancel := context.WithCancel(ctx)
	var wg sync.WaitGroup
	defer func() { close(ch); cancel(); wg.Wait() }()

	wg.Add(1)
	go func() {
		defer wg.Done()
		for req := range ch {
			switch req.header.MessageName {
			{{ range $meth := $svc.Methods }}
			case "{{ $meth.Name }}":
				args := req.args.(*{{ $svc.Name }}{{ $meth.Name }}Args)
			{{ if $meth.Oneway }}
				h.handler.{{ $meth.Name }}(ctx, {{ range $meth.Arguments }}args.{{ fieldName .Name }}, {{ end }} )
				continue
			{{ else if (eq $meth.ReturnType.Name "void" ) }}
				err := h.handler.{{ $meth.Name }}(ctx, {{ range $meth.Arguments }}args.{{ fieldName .Name }}, {{ end }} )
				result := New{{ $svc.Name }}{{ $meth.Name }}Result()
			{{ else }}
				ret, err := h.handler.{{ $meth.Name }}(ctx, {{ range $meth.Arguments }}args.{{ fieldName .Name }}, {{ end }} )
				result := New{{ $svc.Name }}{{ $meth.Name }}Result()
				if ret != nil {
					result.Success = ret
				}
			{{ end }}
			{{ if (not $meth.Oneway) }}
				var rspHeader = protocol.MessageHeader{
					MessageName: "{{ $meth.Name }}",
					MessageType: protocol.MessageTypeReply,
					SeqId:       req.header.SeqId,
				}

				var rspBody interface{} = result

				if err != nil {
					switch e := err.(type) {
					{{ if $meth.Exceptions }} {{ range $exc := $meth.Exceptions }}
					case *{{ formatType $exc.Type }}:
						result.{{ fieldName $exc.Name }} = e {{ end }}
					{{ end }}
					default:
						rspHeader.MessageType = protocol.MessageTypeException
						rspBody = thrift.NewApplicationExceptionFromError(e)
					}
				}

				if err = writer.EncodeMessageHeader(rspHeader); err != nil {
					// TODO: log ?
					return
				}
				if err = writer.Encode(rspBody); err != nil {
					// TODO: log ?
					return
				}
			{{ end }}
			{{ end }}
			}
		}
	}()

	for {
		reqHeader, err := reader.DecodeMessageHeader()
		if err != nil {
			return err
		}
		if reqHeader.MessageType != protocol.MessageTypeCall {
			return thrift.ErrMessageType
		}
		var req = request{header: reqHeader}
		switch reqHeader.MessageName {
		{{ range $meth := $svc.Methods }}
		case "{{ $meth.Name }}":
			req.args = New{{ $svc.Name }}{{ $meth.Name }}Args()
		{{ end }}
		default:
			return thrift.ErrUnknownFunction
		}
		if err = reader.Decode(req.args); err != nil {
			return err
		}
		ch <- req
	}
}

{{ end }}
`
