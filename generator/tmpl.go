package generator

import "fmt"

var headerTmpl = fmt.Sprintf(`
// GENERATED BY GOTHRIFTER (version: %s)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package {{ .Name }}

import (
	"bytes"
	"context"
	"fmt"
	"sync"

	"github.com/thrift-iterator/go"
	"github.com/thrift-iterator/go/protocol"
	"github.com/jxskiss/gothrifter/lib/thrift"

	{{ range .Includes }} {{ .Name }} "{{ .ImportPath }}"
	{{ end }}
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = bytes.Equal
	_ = context.Canceled
	_ = fmt.Printf
	_ = sync.WaitGroup{}
	_ = protocol.MessageHeader{}
	_ = thrifter.DefaultConfig
	_ = thrift.UNKNOWN_APPLICATION_EXCEPTION

	{{ range .Includes }} _ = {{ .Name }}.GoUnusedProtection__
	{{ end }}

	GoUnusedProtection__ = 0
)
`, Version)

const constsTmpl = `
const (
	MaxMapElements    = 1 << 20
	MaxSetElements    = 1 << 20
	MaxListElements   = 1 << 20
	MaxServerPipeline = 10
)

{{ range $enum := .Enums }}
type {{ $enum.Name }} int32

const (
	{{ range $enum.Values }}
	{{ $enum.Name }}_{{ .Name }} {{ $enum.Name }} = {{ .Value }}
	{{ end }}
)
{{ end }}

{{ range .Constants }}
{{ if (eq .Type.Category "container") }}
var {{ .Name }} = {{ formatType .Type }}{{ formatValue .Value }}
{{ else }}
const {{ .Name }} {{ formatType .Type }} = {{ formatValue .Value }}
{{ end }}
{{ end }}
`

const typedefsTmpl = `
{{ range .Typedefs }}
type {{ .Alias }} = {{ formatType .Type }}
{{ end }}
`

const structsTmpl = `
{{ range $struct := .Structs }}

{{ range $struct.Fields }}
{{ if (and .Default (not (eq .Type.Category "container") ) ) }}
var {{ toCamelCase $struct.Name }}_{{ toCamelCase .Name }}_DEFAULT {{ formatType .Type }} = {{ formatValue .Default }}
{{ end }}
{{ end }}

type {{ toCamelCase $struct.Name }} struct { {{ range $struct.Fields }}
	{{ toCamelCase .Name }} {{ if (and .Optional (not .Default)) }}*{{ end }}{{ formatType .Type }}` +
	" `thrift:\"{{ .Name }},{{ .ID }}{{ if (not (eq .Requiredness \"default\") ) }},{{ .Requiredness }}{{ end }}\"" +
	" json:\"{{ toSnakeCase .Name }}{{ if .Optional }},omitempty{{ end }}\"` " +
`	{{ end }}
}

func New{{ toCamelCase $struct.Name }}() *{{ toCamelCase $struct.Name }} {
	return &{{ toCamelCase $struct.Name }}{
	{{ range $struct.Fields }}
	{{ if  .Default }}
	{{ if (eq .Type.Category "container") }}
	{{ toCamelCase .Name}} : {{ formatType .Type }}{{ formatValue .Default }},
	{{ else }}
	{{ toCamelCase .Name }} : {{ toCamelCase $struct.Name }}_{{ toCamelCase .Name }}_DEFAULT,
	{{ end }}
	{{ end }}
	{{ end }}
	}
}
{{ end }}
`

const exceptionsTmpl = `
{{ range $exc := .Exceptions }}
func (p *{{ .Name }}) Error() string {
	return fmt.Sprintf("%T %#v", *p, *p)
}
{{ end }}
`

const servicesTmpl = `
{{ range $name, $svc := .Services }}
{{ formatArguments $svc }}

type {{ $svc.Name }}Client struct {
	thrift.Client
}

func New{{ $svc.Name }}Client(cli thrift.Client) *{{ $svc.Name }}Client {
	return &{{ $svc.Name }}Client{Client: cli}
}

{{ range $meth := $svc.Methods }}
func (cli *{{ $svc.Name }}Client) {{ toCamelCase $meth.Name }}(ctx context.Context,
	{{ range $meth.Arguments }}{{ .Name }} {{ if (eq .Type.Category "identifier") }}*{{ end }}{{ formatType .Type }}, {{ end }}
	) ( {{ if (not (or $meth.Oneway (eq $meth.ReturnType.Name "void"))) }} {{ formatReturn $meth.ReturnType }}, {{ end }} error) {
	args := &{{ $svc.Name }}{{ toCamelCase $meth.Name }}Args{
		{{ range $meth.Arguments }}
		{{ toCamelCase .Name }}: {{ .Name }},
		{{ end }}
	}
	{{ if $meth.Oneway }}
	err := cli.Client.Invoke(ctx, "{{ toCamelCase $meth.Name }}", args, nil)
	return err
	{{ else if (eq $meth.ReturnType.Name "void") }}
	result := New{{ $svc.Name }}{{ toCamelCase $meth.Name }}Result()
	err := cli.Client.Invoke(ctx, "{{ toCamelCase $meth.Name }}", args, result)
	return err
	{{ else }}
	result := New{{ $svc.Name }}{{ toCamelCase $meth.Name }}Result()
	zero := result.Success
	err := cli.Client.Invoke(ctx, "{{ toCamelCase $meth.Name }}", args, result)
	if err != nil {
		return zero, err
	}

	{{ if $meth.Exceptions }}
	{{ range $exc := $meth.Exceptions }}
	if result.{{ toCamelCase $exc.Name }} != nil {
		return zero, result.{{ toCamelCase $exc.Name }}
	}
	{{ end }}
	{{ end }}

	return result.Success, nil
	{{ end }}
}
{{ end }}

type {{ $svc.Name }}Handler interface {
	{{ range $meth := $svc.Methods }}
	{{ toCamelCase $meth.Name }}(ctx context.Context, {{ range $meth.Arguments }}{{ .Name }} {{ if (eq .Type.Category "identifier") }}*{{ end }}{{ formatType .Type }}, {{ end }} ) (
		{{ if (not (or $meth.Oneway (eq $meth.ReturnType.Name "void"))) }} {{ formatReturn $meth.ReturnType }}, {{ end }} error)
	{{ end }}
}

type {{ $svc.Name }}Server struct {
	handler {{ $svc.Name }}Handler
}

func New{{ $svc.Name }}Server(h {{ $svc.Name }}Handler) *{{ $svc.Name }}Server {
	return &{{ $svc.Name }}Server{handler: h}
}

func (h {{ $svc.Name }}Server) Process(ctx context.Context, reader *thrifter.Decoder, writer *thrifter.Encoder) error {
	type request struct {
		header protocol.MessageHeader
		args   interface{}
	}
	ch := make(chan request, MaxServerPipeline)
	ctx, cancel := context.WithCancel(ctx)
	var wg sync.WaitGroup
	defer func() { close(ch); cancel(); wg.Wait() }()

	wg.Add(1)
	go func() {
		defer wg.Done()
		for req := range ch {
			var rspHeader = protocol.MessageHeader{
				MessageType: protocol.MessageTypeReply,
				MessageName: req.header.MessageName,
				SeqId:       req.header.SeqId,
			}
			var rspBody interface{}
			switch req.header.MessageName {
			{{ range $meth := $svc.Methods }}
			case "{{ toCamelCase $meth.Name }}":
			{{ if $meth.Arguments }} args := req.args.(*{{ $svc.Name }}{{ toCamelCase $meth.Name }}Args) {{ end }}
			{{ if $meth.Oneway }}
				err := h.handler.{{ toCamelCase $meth.Name }}(ctx, {{ range $meth.Arguments }}args.{{ toCamelCase .Name }}, {{ end }} )
				if err != nil {
					// TODO
				}
				continue
			{{ else if (eq $meth.ReturnType.Name "void" ) }}
				result := New{{ $svc.Name }}{{ toCamelCase $meth.Name }}Result()
				err := h.handler.{{ toCamelCase $meth.Name }}(ctx, {{ range $meth.Arguments }}args.{{ toCamelCase .Name }}, {{ end }} )
			{{ else }}
				result := New{{ $svc.Name }}{{ toCamelCase $meth.Name }}Result()
				ret, err := h.handler.{{ toCamelCase $meth.Name }}(ctx, {{ range $meth.Arguments }}args.{{ toCamelCase .Name }}, {{ end }} )
				result.Success = ret
			{{ end }}
			{{ if (not $meth.Oneway) }}
				rspBody = result
				if err != nil {
					{{ if $meth.Exceptions }}
					switch e := err.(type) {
					{{ range $exc := $meth.Exceptions }}
					case *{{ formatType $exc.Type }}:
						result.{{ toCamelCase $exc.Name }} = e {{ end }}
					default:
						rspHeader.MessageType = protocol.MessageTypeException
						rspBody = thrift.NewApplicationExceptionFromError(e)
					}
					{{ else }}
					rspHeader.MessageType = protocol.MessageTypeException
					rspBody = thrift.NewApplicationExceptionFromError(err)
					{{ end }}
				}
			{{ end }}
			{{ end }}
			}
			// TODO: log or something?
			if err := writer.EncodeMessageHeader(rspHeader); err != nil {
				return
			}
			if err := writer.Encode(rspBody); err != nil {
				return
			}
		}
	}()

	for {
		reqHeader, err := reader.DecodeMessageHeader()
		if err != nil {
			return err
		}
		if reqHeader.MessageType != protocol.MessageTypeCall {
			return thrift.ErrMessageType
		}
		var req = request{header: reqHeader}
		switch reqHeader.MessageName {
		{{ range $meth := $svc.Methods }}
		case "{{ toCamelCase $meth.Name }}":
			req.args = New{{ $svc.Name }}{{ toCamelCase $meth.Name }}Args()
		{{ end }}
		default:
			return thrift.ErrUnknownFunction
		}
		if err = reader.Decode(req.args); err != nil {
			return err
		}
		ch <- req
	}
}

{{ end }}
`
